{"ast":null,"code":"import \"core-js/modules/es.iterator.constructor.js\";\nimport \"core-js/modules/es.iterator.find.js\";\nimport \"core-js/modules/es.iterator.map.js\";\nimport \"core-js/modules/es.iterator.some.js\";\nimport { ContentFilterFinishReasonError, LengthFinishReasonError, OpenAIError } from \"../error.mjs\";\nexport function makeParseableResponseFormat(response_format, parser) {\n  const obj = {\n    ...response_format\n  };\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-response-format',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function makeParseableTextFormat(response_format, parser) {\n  const obj = {\n    ...response_format\n  };\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-response-format',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function isAutoParsableResponseFormat(response_format) {\n  return response_format?.['$brand'] === 'auto-parseable-response-format';\n}\nexport function makeParseableTool(tool, {\n  parser,\n  callback\n}) {\n  const obj = {\n    ...tool\n  };\n  Object.defineProperties(obj, {\n    $brand: {\n      value: 'auto-parseable-tool',\n      enumerable: false\n    },\n    $parseRaw: {\n      value: parser,\n      enumerable: false\n    },\n    $callback: {\n      value: callback,\n      enumerable: false\n    }\n  });\n  return obj;\n}\nexport function isAutoParsableTool(tool) {\n  return tool?.['$brand'] === 'auto-parseable-tool';\n}\nexport function maybeParseChatCompletion(completion, params) {\n  if (!params || !hasAutoParseableInput(params)) {\n    return {\n      ...completion,\n      choices: completion.choices.map(choice => ({\n        ...choice,\n        message: {\n          ...choice.message,\n          parsed: null,\n          ...(choice.message.tool_calls ? {\n            tool_calls: choice.message.tool_calls\n          } : undefined)\n        }\n      }))\n    };\n  }\n  return parseChatCompletion(completion, params);\n}\nexport function parseChatCompletion(completion, params) {\n  const choices = completion.choices.map(choice => {\n    if (choice.finish_reason === 'length') {\n      throw new LengthFinishReasonError();\n    }\n    if (choice.finish_reason === 'content_filter') {\n      throw new ContentFilterFinishReasonError();\n    }\n    return {\n      ...choice,\n      message: {\n        ...choice.message,\n        ...(choice.message.tool_calls ? {\n          tool_calls: choice.message.tool_calls?.map(toolCall => parseToolCall(params, toolCall)) ?? undefined\n        } : undefined),\n        parsed: choice.message.content && !choice.message.refusal ? parseResponseFormat(params, choice.message.content) : null\n      }\n    };\n  });\n  return {\n    ...completion,\n    choices\n  };\n}\nfunction parseResponseFormat(params, content) {\n  if (params.response_format?.type !== 'json_schema') {\n    return null;\n  }\n  if (params.response_format?.type === 'json_schema') {\n    if ('$parseRaw' in params.response_format) {\n      const response_format = params.response_format;\n      return response_format.$parseRaw(content);\n    }\n    return JSON.parse(content);\n  }\n  return null;\n}\nfunction parseToolCall(params, toolCall) {\n  const inputTool = params.tools?.find(inputTool => inputTool.function?.name === toolCall.function.name);\n  return {\n    ...toolCall,\n    function: {\n      ...toolCall.function,\n      parsed_arguments: isAutoParsableTool(inputTool) ? inputTool.$parseRaw(toolCall.function.arguments) : inputTool?.function.strict ? JSON.parse(toolCall.function.arguments) : null\n    }\n  };\n}\nexport function shouldParseToolCall(params, toolCall) {\n  if (!params) {\n    return false;\n  }\n  const inputTool = params.tools?.find(inputTool => inputTool.function?.name === toolCall.function.name);\n  return isAutoParsableTool(inputTool) || inputTool?.function.strict || false;\n}\nexport function hasAutoParseableInput(params) {\n  if (isAutoParsableResponseFormat(params.response_format)) {\n    return true;\n  }\n  return params.tools?.some(t => isAutoParsableTool(t) || t.type === 'function' && t.function.strict === true) ?? false;\n}\nexport function validateInputTools(tools) {\n  for (const tool of tools ?? []) {\n    if (tool.type !== 'function') {\n      throw new OpenAIError(`Currently only \\`function\\` tool types support auto-parsing; Received \\`${tool.type}\\``);\n    }\n    if (tool.function.strict !== true) {\n      throw new OpenAIError(`The \\`${tool.function.name}\\` tool is not marked with \\`strict: true\\`. Only strict function tools can be auto-parsed`);\n    }\n  }\n}","map":{"version":3,"names":["ContentFilterFinishReasonError","LengthFinishReasonError","OpenAIError","makeParseableResponseFormat","response_format","parser","obj","Object","defineProperties","$brand","value","enumerable","$parseRaw","makeParseableTextFormat","isAutoParsableResponseFormat","makeParseableTool","tool","callback","$callback","isAutoParsableTool","maybeParseChatCompletion","completion","params","hasAutoParseableInput","choices","map","choice","message","parsed","tool_calls","undefined","parseChatCompletion","finish_reason","toolCall","parseToolCall","content","refusal","parseResponseFormat","type","JSON","parse","inputTool","tools","find","function","name","parsed_arguments","arguments","strict","shouldParseToolCall","some","t","validateInputTools"],"sources":["../src/lib/parser.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}